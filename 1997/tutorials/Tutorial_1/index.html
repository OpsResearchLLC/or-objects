<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Don Anderson">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (WinNT; I) [Netscape]">
   <title>OR-Objects Tutorial 1: Shortest Path Applet</title>
</head>
<body background="../../../Images/paper.gif" nosave>
&nbsp;
<table CELLSPACING=4 >
<tr>
<td><a href="http://OpsResearch.com" target="_parent">Home</a></td>

<td><a href="https://github.com/opsresearch/or-objects">OR-Objects</a></td>

<td><a href="../index.html">Tutorials</a></td>

<td><a href="../index.html">Prev</a></td>

<td><a href="../Tutorial_2/index.html">Next</a></td>
</tr>
</table>

<center>
<h1>
Tutorial 1 - Shortest Path Applet</h1></center>

<center><table>
<tr>
<td><img SRC="Tutorial_1.gif" NOSAVE height=190 width=199></td>
</tr>
</table></center>

<center><applet ARCHIVE="../or.jar" CODE="Tutorial_1.class"  WIDTH=199  HEIGHT=90></applet>[If Java were enabled you would see an applet here.]</center>

<p>In this tutorial you will learn how to use OR-Objects to build a graph
like the one pictured above and use it in a shortest path algorithm. This
graph has seven vertices which are labeled '<font color="#FF0000">A</font>'
through '<font color="#FF0000">G</font>'. It has ten edges which connect
the vertices and there is a cost associated with each edge. Eight of the
edges are undirected and the two with arrows are directed. An undirected
edge is one that can be crossed in both directions and a directed edge
is one that can only be crossed in a single direction.
<p>For example, it costs '2' to cross the edge between 'A' and 'B' and
it can be crossed both ways. It costs '1' to cross the edge between 'E'
and 'B', but it can only be crossed from 'E' to 'B'. The algorithm will
find the shortest path from a beginning vertex to a ending vertex making
sure it only crosses the edges in the correct direction. There are many
other properties that can be associated with the vertices and edges, but
this tutorial only uses cost to keep things simple. If you would like to
see an example of a more complex problem see Tutorial-2.
<p>Since this tutorial is about using OR-Objects and not writing applets
some of the applet details will be skipped. You can view the <a href="Tutorial_1.txt">complete
source</a> if you would like more details.
<br>
<hr WIDTH="100%">
<h2>
Tutorial 1 - Contents</h2>

<ul>
<li>
<a href="#theApplet">The Applet</a></li>

<li>
<a href="#initMethod">Initialization</a></li>

<ul>
<li>
<a href="#initAddVertices">Add Vertices</a></li>

<li>
<a href="#initAddEdges">Add Edges</a></li>
</ul>

<li>
<a href="#displayPathMethod">DisplayPath</a></li>

<ul>
<li>
<a href="#displayPathGeneratePaths">Generate Path</a></li>

<li>
<a href="#displayPathGetCost">Get Cost</a></li>

<li>
<a href="#displayPathGetPath">Get Path</a></li>
</ul>
</ul>

<hr WIDTH="100%">
<h2>
<a NAME="theApplet"></a>The Applet</h2>
The following code fragment shows the definition of the 'Tutorial_1'&nbsp;
applet and the declaration of the variable 'algorithm' which will hold
the shortest path algorithm. 'SingleVertexI' is an interface and interfaces
in OR-Objects end with a capital 'I', this is only a convention and isn't
required. There will be more about interfaces later. Notice the 'import'
statement, this tells the compiler where to find the graph classes we are
using.
<ul><tt>import <a href="../../api/drasys/or/graph/package-summary.html" TARGET="API">drasys.or.graph</a>.*;</tt>
<br><tt>import <a href="../../api/drasys/or/graph/sp/package-summary.html" TARGET="API">drasys.or.graph.sp</a>.*;</tt>
<p><tt>public class Tutorial_1</tt>
<br><tt>extends Applet</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <a href="../../api/drasys/or/graph/sp/SingleVertexI.html" TARGET="API">SingleVertexI</a>&nbsp;&nbsp;&nbsp;
algorithm;</tt></ul>

<hr WIDTH="100%">
<h2>
<a NAME="initMethod"></a>Initialization</h2>
This is the initialization function that is called when the browser starts
the applet. It is where the graph is built and the algorithm is initialized.
The following code fragment shows the creation of the graph. Notice that
the graph variable is an interface 'GraphI' and not the class 'SparseGraph'.
This is possible because the 'GraphI' interface is implemented by 'SparseGraph'
and it provides all the functionality we need to operate on the graph.
This is an advantage because 'DenseGraph' implements the 'GraphI' interface
as well, and if we decide to change to a dense graph, all we need to do
is change the creation statement. You will see interfaces used this way
throughout OR-Objects.
<pre><tt>&nbsp;&nbsp;&nbsp; public void
&nbsp;&nbsp;&nbsp; init()
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="../../api/drasys/or/graph/SparseGraph.html" TARGET="API">SparseGraph</a><b> </b>graph = new <a href="../../api/drasys/or/graph/SparseGraph.html#SparseGraph()" TARGET="API">SparseGraph</a>();</tt></pre>

<pre>
<hr WIDTH="100%"></pre>

<h2>
<a NAME="initAddVertices"></a>Initialization - Add Vertices</h2>
The next step in the initialization function is to add the vertices. The
vertices are added before the edges because an edge can not be added before
its vertices. The argument to 'addVertex' is the vertex key. In this tutorial
the vertex keys are strings but they can be any object. All vertices must
have a key and no two vertices can have the same key.
<pre><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add the vertices
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.<a href="../../api/drasys/or/graph/AddVertexI.html#addVertex(java.lang.Object)" TARGET="API">addVertex</a>("a");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addVertex("b");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addVertex("c");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addVertex("d");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addVertex("e");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addVertex("f");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addVertex("g");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addVertex("h");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(<a href="../../api/drasys/or/graph/DuplicateVertexException.html" TARGET="API">DuplicateVertexException </a>e){}</tt></pre>

<pre>
<hr WIDTH="100%"></pre>

<h2>
<a NAME="initAddEdges"></a>Initialization - Add Edges</h2>
This code fragment adds the edges to the graph and constructs the algorithm.
The first two arguments to 'addEdge' are the vertices adjacent to the edge.
The third argument is the value of the edge, this can be any object. Notice
that the last two calls to 'addEdge' have an additional argument, if this
argument is 'true' the edge is directed. Otherwise; it is undirected. For
a directed edge the first vertex is the 'from' vertex and the second is
the 'to'.
<pre><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add the edges
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.<a href="../../api/drasys/or/graph/AddEdgeI.html#addEdge(java.lang.Object, java.lang.Object, java.lang.Object)" TARGET="API">addEdge</a>("a","b",new Double(2));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addEdge("a","c",new Double(2));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addEdge("d","b",new Double(3));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addEdge("d","c",new Double(2));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addEdge("d","e",new Double(2));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addEdge("d","f",new Double(3));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addEdge("g","e",new Double(2));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addEdge("g","f",new Double(2));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.<a href="../../api/drasys/or/graph/AddEdgeI.html#addEdge(java.lang.Object, java.lang.Object, java.lang.Object, boolean)" TARGET="API">addEdge</a>("e","b",new Double(1),true); // directed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.addEdge("c","f",new Double(1),true); // directed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(<a href="../../api/drasys/or/graph/DuplicateEdgeException.html" TARGET="API">DuplicateEdgeException </a>e){}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(<a href="../../api/drasys/or/graph/VertexNotFoundException.html" TARGET="API">VertexNotFoundException </a>e){}</tt></pre>

<pre><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algorithm = new <a href="../../api/drasys/or/graph/sp/Dijkstra.html#Dijkstra(drasys.or.graph.GraphI)" TARGET="API">Dijkstra</a>(graph);
&nbsp;&nbsp;&nbsp; }</tt></pre>

<hr WIDTH="100%">
<h2>
<a NAME="displayPathMethod"></a>DisplayPath</h2>
This is the method that generates the path and displays the results. The
source and destination keys are passed as arguments and first step is to
check to see if the source and destination are the same.
<pre><tt>&nbsp;&nbsp;&nbsp; public void
&nbsp;&nbsp;&nbsp; displayPath(Object src, Object dst)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(src.equals(dst)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pathLabel.setText(src);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; costLabel.setText("0.0");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></pre>

<h2>

<hr WIDTH="100%"><a NAME="displayPathGeneratePaths"></a>DisplayPath - Generate
Path</h2>
The algorithm generates paths from a source vertex to a group of vertices
that are marked as candidates. In this example we only have one candidate
and it is the destination vertex where we want the path to end. The first
call to 'setCandidate' clears all the candidates and the second makes 'dst'
a candidate. Then 'generatePathsFrom' is used to create the path from 'src'
to 'dst'..
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
algorithm.<a href="../../api/drasys/or/graph/sp/SingleVertexI.html#setCandidate(boolean)" TARGET="API">setCandidate</a>(false);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
algorithm.<a href="../../api/drasys/or/graph/sp/SingleVertexI.html#setCandidate(java.lang.Object, boolean)" TARGET="API">setCandidate</a>(dst,
true);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
algorithm.<a href="../../api/drasys/or/graph/sp/SingleVertexI.html#generatePathsFrom(java.lang.Object)" TARGET="API">generatePathsFrom</a>(src);</tt>
<p>The algorithm has a '<a href="../../api/drasys/or/graph/sp/SingleVertexI.html#generatePathsTo(java.lang.Object)" TARGET="API">generatePathsTo</a>'
that is not used here. It creates the paths starting at the candidates
and ending at the destination vertex passed as the argument.
<h2>

<hr WIDTH="100%"><a NAME="displayPathGetCost"></a>DisplayPath - Get Cost</h2>
The 'getNearestCandidate' method is used to get the candidate that has
the shortest path. In this example the destination is the only candidate
so it will be returned and 'getCost' returns the cost of the path.
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
VertexI nearest = algorithm.<a href="../../api/drasys/or/graph/sp/SingleVertexI.html#getNearestCandidate()" TARGET="API">getNearestCandidate</a>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double cost = algorithm.<a href="../../api/drasys/or/graph/sp/SingleVertexI.html#getEdgeValue(drasys.or.graph.VertexI)">getEdgeValue</a>(nearest).<a href="../../api/drasys/or/graph/EdgeValueI.html#getCost(boolean)">getCost</a>(false);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
costLabel.setText(String.valueOf(cost));</tt>
<h2>

<hr WIDTH="100%"><a NAME="displayPathGetPath"></a>DisplayPath - Get Path</h2>
This section gets the path from the algorithm and builds the string representation.
The call to 'getPath' returns a 'Vector' object that contains all the vertices
and edges that make up the path. Then 'elements' method returns an enumeration
that is used to sequence through the elements. The first vertex is added
to the string and the while loop adds the rest.
<pre><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector path = algorithm.<a href="../../api/drasys/or/graph/sp/SingleVertexI.html#getPath(drasys.or.graph.VertexI)" TARGET="API">getPath</a>(nearest);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Enumeration enum = path.elements();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="../../api/drasys/or/graph/VertexI.html" TARGET="API">VertexI</a> vertex = (VertexI)enum.nextElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String pathStr = String.valueOf(vertex.getKey());</tt></pre>

<pre><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(enum.hasMoreElements()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum.nextElement();// Discard Edge //
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertex = (VertexI)enum.nextElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pathStr += " - " + vertex.<a href="../../api/drasys/or/graph/VertexI.html#getKey()" TARGET="API">getKey</a>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pathLabel.setText(pathStr);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(<a href="../../api/drasys/or/graph/VertexNotFoundException.html" TARGET="API">VertexNotFoundException </a>e){}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(<a href="../../api/drasys/or/graph/sp/InvalidPropertyException.html" TARGET="API">InvalidPropertyException</a> e){}
&nbsp;&nbsp;&nbsp; }</tt></pre>

<hr SIZE=5 WIDTH="100%">
<br>&nbsp;

<font size=-1><a href="../copyright.html">Copyright (C) 1997-2000 by DRA
Systems all rights reserved.</a></font><img SRC="../../../cgi/log.cgi?O-Tutorial-1" NOSAVE height=1 width=1>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
</body>
</html>
